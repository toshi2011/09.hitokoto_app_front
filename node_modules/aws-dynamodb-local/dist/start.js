"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const node_child_process_1 = require("node:child_process");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const node_http_1 = require("node:http");
const promises_1 = require("node:timers/promises");
const constants_1 = require("./constants");
const deprecation_1 = require("./deprecation");
const instances_1 = require("./instances");
const defaultOptions = {
    port: 8000,
    cors: '*',
    inMemory: true,
    dbPath: undefined,
    sharedDb: true,
    delayTransientStatuses: true,
    optimizeDbBeforeStartup: true,
    help: false,
    heapInitial: undefined,
    heapMax: undefined,
    docker: false,
    dockerPath: 'docker',
    dockerImage: 'amazon/dynamodb-local',
    installPath: constants_1.defaultInstallPath,
    install_path: undefined,
};
const start = async (customOptions) => {
    const options = { ...defaultOptions, ...customOptions };
    if (options.inMemory && options.dbPath) {
        (0, deprecation_1.deprecation)('Both inMemory set to true and dbPath specified, representing undefined behavior. You should either not specify dbPath, or set inMemory to false. Future versions may throw an error.');
    }
    if (instances_1.instances.get(options.port)) {
        throw new Error(`DynamoDB Local instance already running on port ${options.port}`);
    }
    const jvmArgs = [];
    // See https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.UsageNotes.html#DynamoDBLocal.CommandLineOptions
    const dynamoDbArgs = [];
    if (options.heapInitial) {
        jvmArgs.push(`-Xms${options.heapInitial}`);
    }
    if (options.heapMax) {
        jvmArgs.push(`-Xmx${options.heapMax}`);
    }
    if (options.dbPath) {
        dynamoDbArgs.push('-dbPath', options.dbPath);
    }
    else {
        dynamoDbArgs.push('-inMemory');
    }
    if (options.sharedDb) {
        dynamoDbArgs.push('-sharedDb');
    }
    if (options.cors) {
        dynamoDbArgs.push('-cors', options.cors);
    }
    if (options.delayTransientStatuses) {
        dynamoDbArgs.push('-delayTransientStatuses');
    }
    if (options.optimizeDbBeforeStartup && options.dbPath) {
        dynamoDbArgs.push('-optimizeDbBeforeStartup');
    }
    if (options.help) {
        dynamoDbArgs.push('-help');
    }
    const commonArgs = ['-jar', constants_1.jarFilename, '-port', String(options.port)];
    const dockerArgs = ['run', '-p', `${options.port}:${options.port}`, options.dockerImage];
    if (options.install_path) {
        (0, deprecation_1.deprecation)('Use installPath instead of install_path');
    }
    const installPath = (0, node_path_1.resolve)(options.install_path ?? options.installPath);
    jvmArgs.push(`-Djava.library.path=${installPath}/DynamoDBLocal_lib`);
    const process = options.docker
        ? wrapSpawn(options.dockerPath, [...dockerArgs, ...commonArgs, ...dynamoDbArgs])
        : wrapSpawn('java', [...jvmArgs, ...commonArgs, ...dynamoDbArgs], installPath);
    instances_1.instances.set(options.port, { options, process });
    await waitFor(() => dynamoDBLocalIsReady(process, options.port));
};
exports.start = start;
const wrapSpawn = (executable, args, cwd) => {
    const child = (0, node_child_process_1.spawn)(executable, args, {
        env: node_process_1.env,
        stdio: ['inherit', 'inherit', 'inherit'],
        cwd,
    });
    if (!child.pid) {
        throw new Error(`Unable to start DynamoDB Local. Make sure you have ${executable} in your path.`);
    }
    child.on('error', (error) => {
        throw error;
    });
    return child;
};
const waitFor = async (isComplete) => {
    // eslint-disable-next-line no-await-in-loop
    while (!(await isComplete())) {
        // eslint-disable-next-line no-await-in-loop
        await (0, promises_1.setTimeout)(100);
    }
};
const dynamoDBLocalIsReady = (process, port) => {
    if (process.exitCode) {
        throw new Error(`DynamoDB Local exited with code ${process.exitCode}`);
    }
    return new Promise((res) => {
        const req = (0, node_http_1.get)(`http://localhost:${port}/`, (message) => {
            res(message.statusCode === 400);
        });
        req.on('error', () => {
            res(false);
        });
    });
};
